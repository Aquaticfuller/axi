<html>
<link rel="stylesheet" type="text/css" href="static/rustdoc.css">
<link rel="stylesheet" type="text/css" href="static/light.css">
<link rel="stylesheet" type="text/css" href="static/svdoc.css">
<body>
<section id="main" class="content"><h1 class="fqn">Module <a class="module">axi_iw_converter</a></h1>
<div class="docblock">
<p>Convert between any two AXI ID widths.</p>
<p>Any combination of slave and master port ID width is valid.  When the master port ID width is
larger than or equal to the slave port ID width, slave port IDs are simply prepended with zeros
to the width of master port IDs.  For <em>reducing</em> the ID width, i.e., when the master port ID
width is smaller than the slave port ID width, there are two options.</p>
<h2>Options for reducing the ID width</h2>
<p>The two options for reducing ID widths differ in the maximum number of different IDs that can be
in flight at the slave port of this module, given in the <code>AxiSlvPortMaxUniqIds</code> parameter.</p>
<h3>Fewer unique slave port IDs than master port IDs</h3>
<p>If <code>AxiSlvPortMaxUniqIds &lt;= 2**AxiMstPortIdWidth</code>, there are fewer unique slave port IDs than
master port IDs.  Therefore, IDs that are different at the slave port of this module can remain
different at the reduced-ID-width master port and thus remain <em>independently reorderable</em>.
Since the IDs are master port are nonetheless shorter than at the slave port, they need to be
<em>remapped</em>.  An instance of <a href="module.axi_id_remap"><code>axi_id_remap</code></a> handles this case.</p>
<h3>More unique slave port IDs than master port IDs</h3>
<p>If <code>AxiSlvPortMaxUniqIds &gt; 2**AxiMstPortIdWidth</code>, there are more unique slave port IDs than
master port IDs.  Therefore, some IDs that are different at the slave port need to be assigned
to the same master port ID and thus become ordered with respect to each other.  An instance of
<a href="module.axi_id_serialize"><code>axi_id_serialize</code></a> handles this case.</p>
</div>
<h2 id="parameters" class="section-header"><a href="#parameters">Parameters</a></h2>
<h3 id="parameter.AxiSlvPortIdWidth" class="impl"><code class="in-band">AxiSlvPortIdWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>ID width of the AXI4+ATOP slave port</p>
</div><h3 id="parameter.AxiMstPortIdWidth" class="impl"><code class="in-band">AxiMstPortIdWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>ID width of the AXI4+ATOP master port</p>
</div><h3 id="parameter.AxiSlvPortMaxUniqIds" class="impl"><code class="in-band">AxiSlvPortMaxUniqIds<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>Maximum number of different IDs that can be in flight at the slave port.  Reads and writes are
counted separately (except for ATOPs, which count as both read and write).</p>
<p>It is legal for upstream to have transactions with more unique IDs than the maximum given by
this parameter in flight, but a transaction exceeding the maximum will be stalled until all
transactions of another ID complete.</p>
</div><h3 id="parameter.AxiSlvPortMaxTxnsPerId" class="impl"><code class="in-band">AxiSlvPortMaxTxnsPerId<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>Maximum number of in-flight transactions with the same ID at the slave port.</p>
<p>This parameter is only relevant if <code>AxiSlvPortMaxUniqIds &lt;= 2**AxiMstPortIdWidth</code>.  In that
case, this parameter is passed to <a href="module.axi_id_remap#parameter.AxiMaxTxnsPerId"><code>axi_id_remap</code> as <code>AxiMaxTxnsPerId</code>
parameter</a>.</p>
</div><h3 id="parameter.AxiSlvPortMaxTxns" class="impl"><code class="in-band">AxiSlvPortMaxTxns<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>Maximum number of in-flight transactions at the slave port.  Reads and writes are counted
separately (except for ATOPs, which count as both read and write).</p>
<p>This parameter is only relevant if <code>AxiSlvPortMaxUniqIds &gt; 2**AxiMstPortIdWidth</code>.  In that
case, this parameter is passed to
<a href="module.axi_id_serialize#parameter.AxiSlvPortMaxTxns"><code>axi_id_serialize</code></a>.</p>
</div><h3 id="parameter.AxiMstPortMaxUniqIds" class="impl"><code class="in-band">AxiMstPortMaxUniqIds<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>Maximum number of different IDs that can be in flight at the master port.  Reads and writes
are counted separately (except for ATOPs, which count as both read and write).</p>
<p>This parameter is only relevant if <code>AxiSlvPortMaxUniqIds &gt; 2**AxiMstPortIdWidth</code>.  In that
case, this parameter is passed to
<a href="module.axi_id_serialize#parameter.AxiMstPortMaxUniqIds"><code>axi_id_serialize</code></a>.</p>
</div><h3 id="parameter.AxiMstPortMaxTxnsPerId" class="impl"><code class="in-band">AxiMstPortMaxTxnsPerId<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>Maximum number of in-flight transactions with the same ID at the master port.</p>
<p>This parameter is only relevant if <code>AxiSlvPortMaxUniqIds &gt; 2**AxiMstPortIdWidth</code>.  In that
case, this parameter is passed to
<a href="module.axi_id_serialize#parameter.AxiMstPortMaxTxnsPerId"><code>axi_id_serialize</code></a>.</p>
</div><h3 id="parameter.AxiAddrWidth" class="impl"><code class="in-band">AxiAddrWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>Address width of both AXI4+ATOP ports</p>
</div><h3 id="parameter.AxiDataWidth" class="impl"><code class="in-band">AxiDataWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>Data width of both AXI4+ATOP ports</p>
</div><h3 id="parameter.AxiUserWidth" class="impl"><code class="in-band">AxiUserWidth<span class="type-annotation">: int unsigned</span></code></h3><div class="docblock"
><p>User signal width of both AXI4+ATOP ports</p>
</div><h3 id="parameter.slv_req_t" class="impl"><code class="in-band">slv_req_t<span class="type-annotation">: type</span></code></h3><div class="docblock"
><p>Request struct type of the AXI4+ATOP slave port</p>
</div><h3 id="parameter.slv_resp_t" class="impl"><code class="in-band">slv_resp_t<span class="type-annotation">: type</span></code></h3><div class="docblock"
><p>Response struct type of the AXI4+ATOP slave port</p>
</div><h3 id="parameter.mst_req_t" class="impl"><code class="in-band">mst_req_t<span class="type-annotation">: type</span></code></h3><div class="docblock"
><p>Request struct type of the AXI4+ATOP master port</p>
</div><h3 id="parameter.mst_resp_t" class="impl"><code class="in-band">mst_resp_t<span class="type-annotation">: type</span></code></h3><div class="docblock"
><p>Response struct type of the AXI4+ATOP master port</p>
</div><h2 id="ports" class="section-header"><a href="#ports">Ports</a></h2>
<h3 id="port.clk_i" class="impl"><code class="in-band">clk_i<span class="type-annotation">: input  logic</span></code></h3><div class="docblock"
><p>Rising-edge clock of both ports</p>
</div><h3 id="port.rst_ni" class="impl"><code class="in-band">rst_ni<span class="type-annotation">: input  logic</span></code></h3><div class="docblock"
><p>Asynchronous reset, active low</p>
</div><h3 id="port.slv_req_i" class="impl"><code class="in-band">slv_req_i<span class="type-annotation">: input  slv_req_t</span></code></h3><div class="docblock"
><p>Slave port request</p>
</div><h3 id="port.slv_resp_o" class="impl"><code class="in-band">slv_resp_o<span class="type-annotation">: output slv_resp_t</span></code></h3><div class="docblock"
><p>Slave port response</p>
</div><h3 id="port.mst_req_o" class="impl"><code class="in-band">mst_req_o<span class="type-annotation">: output mst_req_t</span></code></h3><div class="docblock"
><p>Master port request</p>
</div><h3 id="port.mst_resp_i" class="impl"><code class="in-band">mst_resp_i<span class="type-annotation">: input  mst_resp_t</span></code></h3><div class="docblock"
><p>Master port response</p>
</div><h2 id="types" class="section-header"><a href="#types">Types<a></h2>
<table>
<tr><td><a class="type" href="type.addr_t.html">addr_t</a></td><td></td></tr><tr><td><a class="type" href="type.data_t.html">data_t</a></td><td></td></tr><tr><td><a class="type" href="type.slv_id_t.html">slv_id_t</a></td><td></td></tr><tr><td><a class="type" href="type.mst_id_t.html">mst_id_t</a></td><td></td></tr><tr><td><a class="type" href="type.strb_t.html">strb_t</a></td><td></td></tr><tr><td><a class="type" href="type.user_t.html">user_t</a></td><td></td></tr><tr><td><a class="type" href="type.slv_aw_t.html">slv_aw_t</a></td><td></td></tr><tr><td><a class="type" href="type.mst_aw_t.html">mst_aw_t</a></td><td></td></tr><tr><td><a class="type" href="type.w_t.html">w_t</a></td><td></td></tr><tr><td><a class="type" href="type.slv_b_t.html">slv_b_t</a></td><td></td></tr><tr><td><a class="type" href="type.mst_b_t.html">mst_b_t</a></td><td></td></tr><tr><td><a class="type" href="type.slv_ar_t.html">slv_ar_t</a></td><td></td></tr><tr><td><a class="type" href="type.mst_ar_t.html">mst_ar_t</a></td><td></td></tr><tr><td><a class="type" href="type.slv_r_t.html">slv_r_t</a></td><td></td></tr><tr><td><a class="type" href="type.mst_r_t.html">mst_r_t</a></td><td></td></tr></table>
</section>
</body>
</html>
