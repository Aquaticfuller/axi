<html>
<link rel="stylesheet" type="text/css" href="static/rustdoc.css">
<link rel="stylesheet" type="text/css" href="static/light.css">
<link rel="stylesheet" type="text/css" href="static/svdoc.css">
<body>
<section id="main" class="content"><h1 class="fqn">Typedef <a class="type">xbar_cfg_t</a></h1>
<pre>typedef struct packed {
    /// Number of subordinate ports of the crossbar.
    /// This many manager modules are connected to it.
    int unsigned   NumSbrPorts;
    /// Number of manager ports of the crossbar.
    /// This many subordinate modules are connected to it.
    int unsigned   NumMgrPorts;
    /// Maximum number of open transactions each manager connected to the crossbar can have in
    /// flight at the same time.
    int unsigned   MaxMgrTrans;
    /// Maximum number of open transactions each subordinate connected to the crossbar can have in
    /// flight at the same time.
    int unsigned   MaxSbrTrans;
    /// Determine if the internal FIFOs of the crossbar are instantiated in fallthrough mode.
    /// 0: No fallthrough
    /// 1: Fallthrough
    bit            FallThrough;
    /// The Latency mode of the xbar. This determines if the channels on the ports have
    /// a spill register instantiated.
    /// Example configurations are provided with the enum `xbar_latency_e`.
    xbar_latency_e LatencyMode;
    /// This is the number of `axi_multicut` stages instantiated in the line cross of the channels.
    /// Having multiple stages can potentially add a large number of FFs!
    int unsigned   PipelineStages;
    /// AXI ID width of the salve ports. The ID width of the manager ports is determined
    /// Automatically. See `axi_mux` for details.
    int unsigned   IdWidthSbrPorts;
    /// The used ID portion to determine if a different salve is used for the same ID.
    /// See `axi_demux` for details.
    int unsigned   IdUsedSbrPorts;
    /// Are IDs unique?
    bit            UniqueIds;
    /// AXI4+ATOP address field width.
    int unsigned   AddrWidth;
    /// AXI4+ATOP data field width.
    int unsigned   DataWidth;
    /// The number of address rules defined for routing of the transactions.
    /// Each manager port can have multiple rules, should have however at least one.
    /// If a transaction can not be routed the xbar will answer with an `axi_pkg::RESP_DECERR`.
    int unsigned   NumAddrRules;
  } xbar_cfg_t;</pre>
<p>Configuration for <code>axi_xbar</code>.</p>
</section>
</body>
</html>
