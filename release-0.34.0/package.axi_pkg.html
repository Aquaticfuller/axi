<html>
<link rel="stylesheet" type="text/css" href="static/rustdoc.css">
<link rel="stylesheet" type="text/css" href="static/light.css">
<link rel="stylesheet" type="text/css" href="static/svdoc.css">
<body>
<section id="main" class="content"><h1 class="fqn">Package <a class="package">axi_pkg</a></h1>
<div class="docblock">
<p>Contains all necessary type definitions, constants, and generally useful functions.</p>
</div>
<h2 id="parameters" class="section-header"><a href="#parameters">Parameters</a></h2>
<h3 id="parameter.BURST_FIXED" class="impl"><code class="in-band">BURST_FIXED<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>In a fixed burst:</p>
<ul>
<li>The address is the same for every transfer in the burst.</li>
<li>The byte lanes that are valid are constant for all beats in the burst.  However, within
those byte lanes, the actual bytes that have <code>wstrb</code> asserted can differ for each beat in
the burst.
This burst type is used for repeated accesses to the same location such as when loading or
emptying a FIFO.</li>
</ul>
</div><h3 id="parameter.BURST_INCR" class="impl"><code class="in-band">BURST_INCR<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>In an incrementing burst, the address for each transfer in the burst is an increment of the
address for the previous transfer.  The increment value depends on the size of the transfer.
For example, the address for each transfer in a burst with a size of 4 bytes is the previous
address plus four.
This burst type is used for accesses to normal sequential memory.</p>
</div><h3 id="parameter.BURST_WRAP" class="impl"><code class="in-band">BURST_WRAP<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>A wrapping burst is similar to an incrementing burst, except that the address wraps around to
a lower address if an upper address limit is reached.
The following restrictions apply to wrapping bursts:</p>
<ul>
<li>The start address must be aligned to the size of each transfer.</li>
<li>The length of the burst must be 2, 4, 8, or 16 transfers.</li>
</ul>
</div><h3 id="parameter.RESP_OKAY" class="impl"><code class="in-band">RESP_OKAY<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>Normal access success.  Indicates that a normal access has been successful. Can also indicate
that an exclusive access has failed.</p>
</div><h3 id="parameter.RESP_EXOKAY" class="impl"><code class="in-band">RESP_EXOKAY<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>Exclusive access okay.  Indicates that either the read or write portion of an exclusive access
has been successful.</p>
</div><h3 id="parameter.RESP_SLVERR" class="impl"><code class="in-band">RESP_SLVERR<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>Slave error.  Used when the access has reached the slave successfully, but the slave wishes to
return an error condition to the originating master.</p>
</div><h3 id="parameter.RESP_DECERR" class="impl"><code class="in-band">RESP_DECERR<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>Decode error.  Generated, typically by an interconnect component, to indicate that there is no
slave at the transaction address.</p>
</div><h3 id="parameter.CACHE_BUFFERABLE" class="impl"><code class="in-band">CACHE_BUFFERABLE<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>When this bit is asserted, the interconnect, or any component, can delay the transaction
reaching its final destination for any number of cycles.</p>
</div><h3 id="parameter.CACHE_MODIFIABLE" class="impl"><code class="in-band">CACHE_MODIFIABLE<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>When HIGH, Modifiable indicates that the characteristics of the transaction can be modified.
When Modifiable is LOW, the transaction is Non-modifiable.</p>
</div><h3 id="parameter.CACHE_RD_ALLOC" class="impl"><code class="in-band">CACHE_RD_ALLOC<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>When this bit is asserted, read allocation of the transaction is recommended but is not
mandatory.</p>
</div><h3 id="parameter.CACHE_WR_ALLOC" class="impl"><code class="in-band">CACHE_WR_ALLOC<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>When this bit is asserted, write allocation of the transaction is recommended but is not
mandatory.</p>
</div><h3 id="parameter.ATOP_ATOMICSWAP" class="impl"><code class="in-band">ATOP_ATOMICSWAP<span class="type-annotation">: </span></code></h3><div class="docblock"
><ul>
<li>Sends a single data value with an address.</li>
<li>The target swaps the value at the addressed location with the data value that is supplied in
the transaction.</li>
<li>The original data value at the addressed location is returned.</li>
<li>Outbound data size is 1, 2, 4, or 8 bytes.</li>
<li>Inbound data size is the same as the outbound data size.</li>
</ul>
</div><h3 id="parameter.ATOP_ATOMICCMP" class="impl"><code class="in-band">ATOP_ATOMICCMP<span class="type-annotation">: </span></code></h3><div class="docblock"
><ul>
<li>Sends two data values, the compare value and the swap value, to the addressed location.
The compare and swap values are of equal size.</li>
<li>The data value at the addressed location is checked against the compare value:
<ul>
<li>If the values match, the swap value is written to the addressed location.</li>
<li>If the values do not match, the swap value is not written to the addressed location.</li>
</ul>
</li>
<li>The original data value at the addressed location is returned.</li>
<li>Outbound data size is 2, 4, 8, 16, or 32 bytes.</li>
<li>Inbound data size is half of the outbound data size because the outbound data contains both
compare and swap values, whereas the inbound data has only the original data value.</li>
</ul>
</div><h3 id="parameter.ATOP_NONE" class="impl"><code class="in-band">ATOP_NONE<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>Perform no atomic operation.</p>
</div><h3 id="parameter.ATOP_ATOMICSTORE" class="impl"><code class="in-band">ATOP_ATOMICSTORE<span class="type-annotation">: </span></code></h3><div class="docblock"
><ul>
<li>Sends a single data value with an address and the atomic operation to be performed.</li>
<li>The target performs the operation using the sent data and value at the addressed location as
operands.</li>
<li>The result is stored in the address location.</li>
<li>A single response is given without data.</li>
<li>Outbound data size is 1, 2, 4, or 8 bytes.</li>
</ul>
</div><h3 id="parameter.ATOP_ATOMICLOAD" class="impl"><code class="in-band">ATOP_ATOMICLOAD<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>Sends a single data value with an address and the atomic operation to be performed.</p>
<ul>
<li>The original data value at the addressed location is returned.</li>
<li>The target performs the operation using the sent data and value at the addressed location as
operands.</li>
<li>The result is stored in the address location.</li>
<li>Outbound data size is 1, 2, 4, or 8 bytes.</li>
<li>Inbound data size is the same as the outbound data size.</li>
</ul>
</div><h3 id="parameter.ATOP_LITTLE_END" class="impl"><code class="in-band">ATOP_LITTLE_END<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>For AtomicStore and AtomicLoad transactions <code>AWATOP[3]</code> indicates the endianness that is
required for the atomic operation.  The value of <code>AWATOP[3]</code> applies to arithmetic operations
only and is ignored for bitwise logical operations.
When deasserted, this bit indicates that the operation is little-endian.</p>
</div><h3 id="parameter.ATOP_BIG_END" class="impl"><code class="in-band">ATOP_BIG_END<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>When asserted, this bit indicates that the operation is big-endian.</p>
</div><h3 id="parameter.ATOP_ADD" class="impl"><code class="in-band">ATOP_ADD<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>The value in memory is added to the sent data and the result stored in memory.</p>
</div><h3 id="parameter.ATOP_CLR" class="impl"><code class="in-band">ATOP_CLR<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>Every set bit in the sent data clears the corresponding bit of the data in memory.</p>
</div><h3 id="parameter.ATOP_EOR" class="impl"><code class="in-band">ATOP_EOR<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>Bitwise exclusive OR of the sent data and value in memory.</p>
</div><h3 id="parameter.ATOP_SET" class="impl"><code class="in-band">ATOP_SET<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>Every set bit in the sent data sets the corresponding bit of the data in memory.</p>
</div><h3 id="parameter.ATOP_SMAX" class="impl"><code class="in-band">ATOP_SMAX<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>The value stored in memory is the maximum of the existing value and sent data. This operation
assumes signed data.</p>
</div><h3 id="parameter.ATOP_SMIN" class="impl"><code class="in-band">ATOP_SMIN<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>The value stored in memory is the minimum of the existing value and sent data. This operation
assumes signed data.</p>
</div><h3 id="parameter.ATOP_UMAX" class="impl"><code class="in-band">ATOP_UMAX<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>The value stored in memory is the maximum of the existing value and sent data. This operation
assumes unsigned data.</p>
</div><h3 id="parameter.ATOP_UMIN" class="impl"><code class="in-band">ATOP_UMIN<span class="type-annotation">: </span></code></h3><div class="docblock"
><p>The value stored in memory is the minimum of the existing value and sent data. This operation
assumes unsigned data.</p>
</div><h3 id="parameter.ATOP_R_RESP" class="impl"><code class="in-band">ATOP_R_RESP<span class="type-annotation">: </span></code></h3><div class="docblock"
></div><h3 id="parameter.DemuxAw" class="impl"><code class="in-band">DemuxAw<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Demux AW channel.</p>
</div><h3 id="parameter.DemuxW" class="impl"><code class="in-band">DemuxW<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Demux W channel.</p>
</div><h3 id="parameter.DemuxB" class="impl"><code class="in-band">DemuxB<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Demux B channel.</p>
</div><h3 id="parameter.DemuxAr" class="impl"><code class="in-band">DemuxAr<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Demux AR channel.</p>
</div><h3 id="parameter.DemuxR" class="impl"><code class="in-band">DemuxR<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Demux R channel.</p>
</div><h3 id="parameter.MuxAw" class="impl"><code class="in-band">MuxAw<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Mux AW channel.</p>
</div><h3 id="parameter.MuxW" class="impl"><code class="in-band">MuxW<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Mux W channel.</p>
</div><h3 id="parameter.MuxB" class="impl"><code class="in-band">MuxB<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Mux B channel.</p>
</div><h3 id="parameter.MuxAr" class="impl"><code class="in-band">MuxAr<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Mux AR channel.</p>
</div><h3 id="parameter.MuxR" class="impl"><code class="in-band">MuxR<span class="type-annotation">: logic [9:0]</span></code></h3><div class="docblock"
><p>Slice on Mux R channel.</p>
</div><h2 id="types" class="section-header"><a href="#types">Types<a></h2>
<table>
<tr><td><a class="type" href="type.burst_t.html">burst_t</a></td><td><p>AXI Transaction Burst Type.</p>
</td></tr><tr><td><a class="type" href="type.resp_t.html">resp_t</a></td><td><p>AXI Transaction Response Type.</p>
</td></tr><tr><td><a class="type" href="type.cache_t.html">cache_t</a></td><td><p>AXI Transaction Cacheability Type.</p>
</td></tr><tr><td><a class="type" href="type.prot_t.html">prot_t</a></td><td><p>AXI Transaction Protection Type.</p>
</td></tr><tr><td><a class="type" href="type.qos_t.html">qos_t</a></td><td><p>AXI Transaction Quality of Service Type.</p>
</td></tr><tr><td><a class="type" href="type.region_t.html">region_t</a></td><td><p>AXI Transaction Region Type.</p>
</td></tr><tr><td><a class="type" href="type.len_t.html">len_t</a></td><td><p>AXI Transaction Length Type.</p>
</td></tr><tr><td><a class="type" href="type.size_t.html">size_t</a></td><td><p>AXI Transaction Size Type.</p>
</td></tr><tr><td><a class="type" href="type.atop_t.html">atop_t</a></td><td><p>AXI5 Atomic Operation Type.</p>
</td></tr><tr><td><a class="type" href="type.nsaid_t.html">nsaid_t</a></td><td><p>AXI5 Non-Secure Address Identifier.</p>
</td></tr><tr><td><a class="type" href="type.largest_addr_t.html">largest_addr_t</a></td><td><p>An overly long address type.</p>
</td></tr><tr><td><a class="type" href="type.mem_type_t.html">mem_type_t</a></td><td><p>Memory Type.</p>
</td></tr><tr><td><a class="type" href="type.xbar_latency_e.html">xbar_latency_e</a></td><td><p>Latency configuration for <code>axi_xbar</code>.</p>
</td></tr><tr><td><a class="type" href="type.xbar_cfg_t.html">xbar_cfg_t</a></td><td><p>Configuration for <code>axi_xbar</code>.</p>
</td></tr><tr><td><a class="type" href="type.xbar_rule_64_t.html">xbar_rule_64_t</a></td><td><p>Commonly used rule types for <code>axi_xbar</code> (64-bit addresses).</p>
</td></tr><tr><td><a class="type" href="type.xbar_rule_32_t.html">xbar_rule_32_t</a></td><td><p>Commonly used rule types for <code>axi_xbar</code> (32-bit addresses).</p>
</td></tr></table>
</section>
</body>
</html>
